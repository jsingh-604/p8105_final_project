---
title: "Final Report"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
    toc_depth: 4
    theme: cosmo
---

```{r}

library(tidyverse)
library(tidytext)  
library(ggplot2)
library(httr)
library(rvest)
library(lubridate)
library(plotly)
library(patchwork)
library(lmtest)
library(dplyr)
library(tidycensus)
require(data.table)
library(gridExtra)
library(ggplot2)
library(shiny)
```


## Motivation

In 2020, the world entered into a pandemic and now two years later as we recover and try to move on with life, things are different. The pandemic brought with it a new lens that showed disparities based on SES, geographical location, etc. that always existed but were never taken seriously. Research has shown that people of color and those from a low SES are at higher risk to contracting COVID-19; as such, public health professionals should be aware of such gaps and make it an effort to especially focus on these groups at higher risk (Khanijahani et al., 2021).



## Analysis and Relevance:

Our project looks at the change in COVID-19 trends in New York State for each county, specifically how COVID-19 is spatially autocorrelated across the different counties and the extent auto-correlation within New York City, the most populated county. We also looked at whether health behaviors and socioeconomic (SES) factors are associated with this change in trends by county. These analyses can be helpful to public health officials in the following ways:
  
First, understanding the spatial patterns of COVID-19 trends can help public health officials to identify areas that are at higher risk for the spread of the virus. This information can be used to target interventions and resources to these areas in order to reduce the spread of COVID-19 and protect the health of the population.

Second, examining the relationship between health behaviors and SES factors and the change in COVID-19 trend can help public health officials to identify potential risk factors for the spread of the virus. This information can be used to develop targeted interventions and policies that aim to reduce the risk of COVID-19 transmission by addressing these factors.

Overall, studying the change in COVID-19 trend in New York State for each county, and examining spatial autocorrelation and the relationship with health behaviors and SES factors, can provide valuable insights. These discoveries can help public health officials to better understand the spread of COVID-19 and take effective action to reduce the risk of transmission in communities at higher risk and address presisting health disparities.

## Data Processing and Cleaning 













## Exploratory Data Analysis

In order to have a better understanding of the existing socioeconomic and health factor status of the counties we conducted some exploratory data analysis mainly through visualization. We first tried to see which counties have the highest socio-economic and heath factor scores

```{r}
library(plotly)
data = read.csv("./data/bubble.csv") %>%
  mutate(County = as.factor(County),
         health = as.numeric(health),
         socio = as.numeric(socio)) %>%
  janitor::clean_names()


total <- merge(data,NY_df,by="county")

fig <- plot_ly(total, x = ~health, y = ~socio, text = ~county, type = 'scatter',
               mode = 'markers', size = ~tpop, color = ~county, colors = 'Paired',
               marker = list(opacity = 0.5, sizemode = 'diameter'))
fig <- fig %>% layout(title = 'health-socio',
                      xaxis = list(showgrid = FALSE),
                      yaxis = list(showgrid = FALSE),
                      showlegend = FALSE)

fig

```

From the plot we can see that New York, Queens and Kings have the highest socio economic score, but have the lowest health factors ranks. The size of the bubble signifies total population of the county. Nassau, Suffolk, Westcher have low health and socio-ecnomic scores. 

Below is a colorpleth map to good understanding on the above in a spatial context,: 

```{r}
census_api_key("aa512886c5449a582d837da8d3a07af66a043fe5")

census_data <- load_variables(2018, "acs5", cache=T)
fwrite(census_data, "census_variables.csv")

vars <- c(tpop = 'P001001',
          medage = 'P013001',
          wpop = 'P003002',
          bpop = 'P003003',
          apop = 'P003005',
          hpop = 'P004003')

NY_df <- get_decennial(state = "ny", 
                       geography = "county",
                       variables = vars,
                       geometry = T,
                       output = "wide")

NY_df = NY_df %>%
  mutate(
    county = gsub(" County, New York","",NAME))


p1 = NY_df  %>%
  ggplot(aes(fill = medage)) + 
  geom_sf(color = NA) + 
  scale_fill_viridis_c(option = "magma") 

total$Geometry = total$geometry
p2 =  total %>%
  ggplot(aes(fill = health)) + 
  geom_sf(color = NA) + 
  scale_fill_viridis_c(option = "magma") 
library(gridExtra)
library(ggplot2)
grid.arrange(p1,p2,nrow,x= 1)

```

On the left we can see a chloropleth mao of medage per county in new york on the right is a chloropleth map of health factor rank per county. 

```{r NY vax plot}
ny_vax =
  read_csv("./grace/ny_covidvax.csv") %>% 
  janitor::clean_names() %>% 
  select(-region, -series_complete) %>% 
  rename(date = report_as_of) %>% 
  mutate(date = lubridate::mdy(date))
vax_plotly =
  ny_vax %>%
  filter(date == "2022-11-14") %>%
  mutate(county = fct_reorder(county, first_dose, .desc = TRUE)) %>%
  mutate(text_label = str_c("County: ", county, "\nVaccinations: ", first_dose)) %>% 
  plot_ly(x = ~county, 
          y = ~first_dose, 
          type = "bar", 
          text = ~text_label) |>
          layout(xaxis = list(title = "County in New York State"), 
                 yaxis = list(title = "Cumulative Number of People with at least one dose"),          
                 title = "Cumulative people with at least one dose of any COVID-19 vaccine by county by 11/14/2022")
vax_plotly
```
From the plot created of the cumulative distribution of people who have at-least the first dose of any COVID-19 vaccine by 11/14/2022, the highest ranking counties are all located in three major regions of New York State: New York City, Long Island, and Hudson Valley. Erie and Monroe counties also have high counts and they are from Western NY and Finger Lakes. This is expected as these are some of the most populous counties in New York State.

```{r}
ny_death =
  read_csv("./grace/ny_coviddeaths.csv") %>% 
  janitor::clean_names() %>%
  rename(date = report_date, n_fatality = place_of_fatality) %>% 
  mutate(date = lubridate::mdy(date)) %>%
  select(-deaths_by_county_of_residence) %>%
  filter(county != "Statewide Total")
deaths_plotly =
  ny_death %>%
  filter(date == "2022-11-14") %>%
  mutate(county = fct_reorder(county, n_fatality, .desc = TRUE)) %>% 
  mutate(text_label = str_c("County: ", county, "\nDeaths: ", n_fatality)) %>% 
  plot_ly(x = ~county, 
          y = ~n_fatality, 
          type = "bar", 
          text = ~text_label) |>
          layout(xaxis = list(title = "County in New York State"), 
                 yaxis = list(title = "Cumulative Number of Fatalities"),          
                 title = "Cumulative COVID-19 deaths by county by 11/14/2022")
deaths_plotly

```
From the plot created of the cumulative distribution of people who have died from COVID-19 by 11/14/2022, the highest ranking counties are also all located in three major regions of New York State: New York City, Long Island, and Hudson Valley, along with Erie and Monroe counties from Western NY and Finger Lakes. Again, this is expected as these are some of the most populous counties in New York State. 


# Statistical Analysis 

```{r}



```

# Spatial Analysis

```{r}
ny_covid = read.csv('data/covid_testing.csv')  %>%
  janitor::clean_names()

###############################
ny_covid$test_date = lubridate::mdy(ny_covid$test_date)
##############################
total <- merge(ny_covid,NY_df,by="county")


```



```{r}

group_df =  sub_df %>% group_by(county)  %>%
summarise(total_covid = sum(new_positives))


mon = seq(as.Date("2021-01-01"), as.Date("2022-01-01"), by = "3 months")
df_list = list()
# loop version 2
for (i in 1:4) {
  print(i)
  sub_df = total[total$test_date >= mon[[i]] & total$test_date <= mon[[i+1]], ]
  group_df =  sub_df %>% group_by(county)  %>%
    summarise(total_covid = sum(new_positives))
  df = dplyr :: left_join(group_df, NY_df, by = 'county')
  df_list[[i]] = df
}


p <- list()
for(i in 1:4){
  p[[i]] <- df_list[[i]] %>%
    ggplot() +
    geom_sf(aes(fill = total_covid, geometry = geometry)) + 
    scale_fill_viridis_c(option = "viridis") 
}
do.call(grid.arrange,p)

```
The above 4 chloroplast maps are a summary 


# Autoregression

```{r}
ny_covid = read.csv('data/covid_testing.csv')  %>%
  janitor::clean_names()

######################################################
ny_covid$test_date = lubridate::mdy(ny_covid$test_date)
sub_df = ny_covid[ny_covid$county == 'New York City', ]
sub_df<- sub_df[seq(dim(sub_df)[1],1),]

# basic scatterplot
ggplot(sub_df, aes(x=test_date, y=new_positives)) + 
  geom_point(alpha = 10/100, colour = "red") + 
  scale_x_date(date_labels = "%m-%Y") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1)) +
  labs(title = "New positives per month in NYC")

```
The above plot is a scatter plot of the daily positive cases in New York City from March 2020 up-till now. We can see the wave like trend, especially from hill shaped curves at the start of the 2020, start of 2021, start of 2022 when it peaked around mid 2022. This implies the existence of auto regressive behavior which we were interested to investigate. To better understand the auto-regressive trend we built a Autocorrelation Function (ACF) plot and Partial Autocorrelation Function (PACF) plot. The ACF and PACF plots are used to figure out the order of AR, MA, and ARMA models. Autocorrelation is the correlation between a time series with a lagged version.
The partial autocorrelation at lag k is the autocorrelation between X_t_t and X_(t-k) that is not accounted for by lags 1 through ð‘˜âˆ’1. 


```{r}
library(forecast)
library(ggplot2)

conf.level <- 0.95
ciline <- qnorm((1 - conf.level)/2)/sqrt(length(sub_df$new_positives))

############# ACF ####################
bacf <- acf(sub_df$new_positives, plot = FALSE)
bacfdf <- with(bacf, data.frame(lag, acf))

p1 <- ggplot(data=bacfdf, mapping=aes(x=lag, y=acf)) +
       geom_bar(stat = "identity", position = "identity")


########### PACF ###################
bacf <- pacf(sub_df$new_positives, plot = FALSE)
bacfdf <- with(bacf, data.frame(lag, acf))


p2 <- ggplot(data=bacfdf, mapping=aes(x=lag, y=acf)) +
  geom_bar(stat = "identity", position = "identity",fill="lightblue")  

grid.arrange(p1,p2)

```
Both the ACF and PACF start with a lag of 0, which is the correlation of the time series with itself and therefore results in a correlation of 1. However after a lag of 1, ACF gives us values of auto-correlation of any series with its lagged values whereas PACF finds correlation of the residuals that remains after removing the effects which are already explained by the earlier lag(s). Thus PACF might be a better indicator of how many lag terms to keep. In our case we decided to move with the 8 lag terms since they seem to have significant partial autcorrelation with value at lag = 0 (present value).

```{r}
reg1 = arima(sub_df$new_positives, order = c(8,0,0))
summary(reg1)
```
The coefficients for an AR(8) model represent the weights that are applied to the past 8 values of the time series (i.e. $y_{t-1}$, $y_{t-2}$, $y_{t-3}$, $y_{t-4}$, $y_{t-5}$, $y_{t-6}$, $y_{t-7}$, $y_{t-8}$) in order to predict the next value of the time series ($\hat{y}_t$). In this case, the coefficients are as follows:

These coefficients can be used to write the ARIMA (8,0,0) equation as follows:

$\hat{y}t = \alpha_1 y{t-1} + \alpha_2 y_{t-2} + \alpha_3 y_{t-3} + \alpha_4 y_{t-4} + \alpha_5 y_{t-5} + \alpha_6 y_{t-6} + \alpha_7 y_{t-7} + \alpha_8 y_{t-8} + \beta_0$

$\begin{aligned} \hat{y}t &= 1.0562 \cdot y_{t-1} - 0.2312 \cdot y_{t-2} + 0.0948 \cdot y_{t-3} + 0.0779 \cdot y_{t-4} - 0.1035 \cdot y_{t-5} + 0.1343 \cdot y_{t-6} + 0.3918 \cdot y_{t-7} - 0.4517 \cdot y_{t-8} + 2924.354 \end{aligned}$

This equation can be used to predict the next value of the time series, $\hat{y}_t$, based on the past 8 values of the time series. The coefficients in the equation represent the relative importance of each of the past values in predicting the next value.

Plotting the fitted values alongside the positive covid cases:
```{r}
ar = fitted(reg1)
ggplot(sub_df, aes(x=test_date, y=new_positives)) + 
  geom_point(alpha = 20/100, color = "red") + 
  scale_x_date(date_labels = "%m-%Y",date_breaks = "1 month") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1)) +
  labs(title = "Scatter Plot of Daily Postive Cases in New York City from 2020-2022
       with ARIMA trend line", x= "Test Date",
       y = 'Positive Cases Detected') +
  geom_line(aes(y=ar,color = "ARIMA trend line")) +  
  scale_color_manual(values = c("ARIMA trend line" = "black"),
                                          labels = "Fitted Arima Model")

```